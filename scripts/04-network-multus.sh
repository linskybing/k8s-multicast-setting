#!/bin/bash
set -u
set -e

# ================= Configuration =================
MULTUS_VERSION="v4.0.2"
WHEREABOUTS_VERSION="v0.6.3"
MULTUS_MEM_LIMIT="512Mi"
CNI_CONF_DIR="/etc/cni/net.d"
NAD_NAME=${NAD_NAME:-macvlan-conf}
NAD_NAMESPACE=${NAD_NAMESPACE:-default}
# Default manifest path in repo (more portable)
MANIFEST_PATH=${MANIFEST_PATH:-"../manifests/cni/${NAD_NAME}.yaml"}

# Interconnect Network intent (internal-only):
# - 25G: 192.168.110.X/24 for GPUX (recommended for Storage traffic)
# - 10G: 192.168.110.10X/24 for GPUX (recommended for Cluster internal interconnect)
# Detect and bind to the interconnect subnet by default.
TARGET_CIDR=${TARGET_CIDR:-"192.168.110.0/24"}

# Whether to inject a default route (0.0.0.0/0) in NAD
# For internal-only interconnect, keep false.
NAD_DEFAULT_ROUTE=${NAD_DEFAULT_ROUTE:-false}

# Prefer binding Multus NAD to the 25G NIC explicitly when multiple NICs share the same CIDR.
# Set STORAGE_IFACE to your 25G interface name to avoid ambiguity.
STORAGE_IFACE=${STORAGE_IFACE:-"enp193s0f0np0"}

# Optional second NAD dedicated to Storage (25G)
STORAGE_NAD_NAME=${STORAGE_NAD_NAME:-storage-macvlan}
STORAGE_NAD_NAMESPACE=${STORAGE_NAD_NAMESPACE:-$NAD_NAMESPACE}
STORAGE_MANIFEST_PATH=${STORAGE_MANIFEST_PATH:-"../manifests/cni/${STORAGE_NAD_NAME}.yaml"}
STORAGE_DEFAULT_ROUTE=${STORAGE_DEFAULT_ROUTE:-false}

# ================= 0. Pre-flight Checks =================
echo "[INFO] Starting pre-flight checks..."

if [ "$EUID" -ne 0 ]; then 
  echo "[ERROR] Please run as root."
  exit 1
fi

if ! kubectl get nodes > /dev/null 2>&1; then
    echo "[ERROR] kubectl cannot connect to the cluster."
    exit 1
fi

# ================= 1. Cleanup Previous Installation =================
echo "[INFO] Cleaning up previous configurations to ensure a fresh install..."

# 1. Delete the NetworkAttachmentDefinition
kubectl delete -f "$MANIFEST_PATH" 2>/dev/null || echo "   - NAD not found (clean)"
kubectl delete -f "$STORAGE_MANIFEST_PATH" 2>/dev/null || echo "   - Storage NAD not found (clean)"

# 2. Delete DaemonSets
kubectl delete daemonset -n kube-system whereabouts 2>/dev/null || echo "   - Whereabouts DS not found (clean)"
kubectl delete daemonset -n kube-system kube-multus-ds 2>/dev/null || echo "   - Multus DS not found (clean)"

# 3. Delete CRDs (To fix the broken state)
echo "[INFO] Refreshing CRDs..."
kubectl delete crd ippools.whereabouts.cni.cncf.io 2>/dev/null || true
kubectl delete crd overlappingrangeipreservations.whereabouts.cni.cncf.io 2>/dev/null || true
# Note: We usually don't delete network-attachment-definitions CRD as it might affect other CNI plugins, 
# but we will ensure it is re-applied later.

# 4. Cleanup CNI configs generated by Multus (Optional but recommended for hard reset)
rm -f /etc/cni/net.d/00-multus.conf
echo "[INFO] Cleanup complete. Waiting 10s for API stability..."
sleep 10

# ================= 2. Auto-Detection Logic =================
echo "[INFO] Detecting network configuration (target CIDR: ${TARGET_CIDR})..."

# Try to find an interface in the TARGET_CIDR (/24 assumed for prefix matching)
TARGET_PREFIX=$(echo "$TARGET_CIDR" | cut -d/ -f1 | cut -d. -f1-3)
INTERCONNECT_IF=$(ip -o -f inet addr show | awk -v pfx="$TARGET_PREFIX" '$4 ~ "^"pfx"\\." {print $2; exit}')
INTERCONNECT_IP=$(ip -o -f inet addr show | awk -v pfx="$TARGET_PREFIX" '$4 ~ "^"pfx"\\." {print $4; exit}')
INTERCONNECT_GW=$(ip route | awk -v pfx="$TARGET_PREFIX" '$1 ~ "^"pfx"\\." {for(i=1;i<=NF;i++) if($i=="via") print $(i+1)}' | head -n1)

# Fallback to default route if TARGET_CIDR interface isn't found
DEFAULT_ROUTE=$(ip route show default | head -n1)
DEFAULT_IF=$(echo "$DEFAULT_ROUTE" | awk '{for(i=1;i<=NF;i++) if($i=="dev") print $(i+1)}')
DEFAULT_GW=$(echo "$DEFAULT_ROUTE" | awk '{for(i=1;i<=NF;i++) if($i=="via") print $(i+1)}')

if [ -z "$INTERCONNECT_IF" ] && [ -z "${MASTER_IF:-}" ]; then
  echo "[WARN] No interface found in ${TARGET_CIDR}. Falling back to default: $DEFAULT_IF"
fi

# Finalize interface and gateway
# If STORAGE_IFACE exists, prefer it for NAD binding to 25G.
if ip -o -f inet addr show "$STORAGE_IFACE" >/dev/null 2>&1; then
  MASTER_IF=${MASTER_IF:-$STORAGE_IFACE}
else
  MASTER_IF=${MASTER_IF:-${INTERCONNECT_IF:-$DEFAULT_IF}}
fi
GATEWAY=${GATEWAY:-${INTERCONNECT_GW}}

if [ -z "$MASTER_IF" ]; then
  echo "[ERROR] Could not detect a master interface. Set MASTER_IF manually."
  exit 1
fi

# Range detection based on TARGET_PREFIX when not provided
if [ -z "${RANGE:-}" ]; then
  IP_PREFIX=${TARGET_PREFIX}
  DETECTED_RANGE="${IP_PREFIX}.110-${IP_PREFIX}.250/24"
  echo "[WARN] using auto-detected range: $DETECTED_RANGE"
else
  DETECTED_RANGE=$RANGE
fi

RANGE=$DETECTED_RANGE

# Derive default storage range if not explicitly provided
if [ -z "${STORAGE_RANGE:-}" ]; then
  STORAGE_RANGE="$RANGE"
fi
STORAGE_GATEWAY=${STORAGE_GATEWAY:-$GATEWAY}

echo "-------------------------------------------------------"
echo "Active Configuration:"
echo "  Interface : $MASTER_IF"
echo "  Gateway   : ${GATEWAY:-<none>}"
echo "  IP Range  : $RANGE"
echo "  DefaultRt : ${NAD_DEFAULT_ROUTE}"
echo "  StorageIF : ${STORAGE_IFACE}"
echo "  StorageRg : ${STORAGE_RANGE}"
echo "  StorageGw : ${STORAGE_GATEWAY:-<none>}"
echo "  StorageRt : ${STORAGE_DEFAULT_ROUTE}"
echo "-------------------------------------------------------"

# Try to detect cluster Pod CIDR to validate no-overlap between Pod network and macvlan range.
# Can be overridden by setting POD_CIDR env var.
if [ -z "${POD_CIDR:-}" ]; then
  POD_CIDR=$(kubectl get nodes -o jsonpath='{.items[0].spec.podCIDR}' 2>/dev/null || true)
fi

echo "Detected POD_CIDR: ${POD_CIDR:-<none>}"

# Validate that macvlan RANGE does not overlap POD_CIDR and that gateway/host IP not inside RANGE
python3 - <<PY || { echo "[ERROR] Network validation failed (overlap or gateway in range). Aborting."; exit 1; }
import ipaddress,sys,re
try:
  # parse POD_CIDR
  pod = ipaddress.ip_network('${POD_CIDR}') if '${POD_CIDR}' else None
  # parse macvlan range (format: 192.168.109.200-192.168.109.250/24)
  s='${RANGE}'
  # handle formats like '192.168.109.200-192.168.109.250/24' or plain CIDR
  m=re.match(r'(.+)-(.+)/([0-9]+)', s)
  range_start = range_end = None
  if not m:
    # try CIDR only
    mac_net=ipaddress.ip_network(s)
    range_start = mac_net.network_address
    range_end = mac_net.broadcast_address
  else:
    start, end, cidr = m.group(1).strip(), m.group(2).strip(), m.group(3).strip()
    # derive network from start with given mask
    mac_net=ipaddress.ip_network(start + '/' + cidr, strict=False)
    range_start = ipaddress.ip_address(start)
    range_end = ipaddress.ip_address(end)

  gw=ipaddress.ip_address('${GATEWAY}') if '${GATEWAY}' else None
  # host IP on MASTER_IF
  import subprocess,json
  try:
    out=subprocess.check_output(['ip','-4','-o','addr','show', '${MASTER_IF}']).decode()
    host_ip=out.split()[3].split('/')[0]
    host_ip=ipaddress.ip_address(host_ip)
  except Exception:
    host_ip=None

  if pod and mac_net and pod.overlaps(mac_net):
    print('ERROR: POD_CIDR overlaps MACVLAN network:', pod, mac_net)
    sys.exit(2)
  # For gateway/host checks, only consider the explicit allocation range (start-end)
  def in_range(ip, start, end):
    try:
      return start <= ip <= end
    except Exception:
      return False

  if gw and range_start and range_end and in_range(gw, range_start, range_end):
    print('ERROR: GATEWAY is inside MACVLAN allocation range:', gw)
    sys.exit(2)
  if host_ip and range_start and range_end and in_range(host_ip, range_start, range_end):
    print('ERROR: Host interface IP is inside MACVLAN allocation range:', host_ip)
    sys.exit(2)
except Exception as e:
  print('Validation exception:', e)
  sys.exit(2)
PY

echo "Network validation passed: POD_CIDR vs MACVLAN range OK"
# ================= 3. Install Multus =================

echo "[INFO] Installing Multus CNI (Thick Plugin)..."
MULTUS_URL="https://raw.githubusercontent.com/k8snetworkplumbingwg/multus-cni/${MULTUS_VERSION}/deployments/multus-daemonset-thick.yml"

curl -sL "$MULTUS_URL" | sed "s/memory: .*/memory: $MULTUS_MEM_LIMIT/g" | kubectl apply -f -

echo "[INFO] Patching Multus DaemonSet for /opt/cni/bin visibility..."
kubectl patch daemonset kube-multus-ds -n kube-system --type='json' -p='[
  {"op": "add", "path": "/spec/template/spec/volumes/-", "value": {"name": "cni-bin", "hostPath": {"path": "/opt/cni/bin", "type": "Directory"}}},
  {"op": "add", "path": "/spec/template/spec/containers/0/volumeMounts/-", "value": {"name": "cni-bin", "mountPath": "/opt/cni/bin"}}
]' || echo "[INFO] Patch might have already been applied."

echo "[INFO] Waiting for Multus rollout..."
kubectl -n kube-system rollout restart daemonset/kube-multus-ds
kubectl -n kube-system rollout status daemonset/kube-multus-ds --timeout=300s

# Apply RBAC needed by Multus/Whereabouts to read pods/nodes (fix permission issues)
RBAC_MANIFEST_PATH="$(dirname "$MANIFEST_PATH")/multus-whereabouts-rbac.yaml"
if [ -f "$RBAC_MANIFEST_PATH" ]; then
  echo "[INFO] Applying Multus/Whereabouts RBAC: $RBAC_MANIFEST_PATH"
  kubectl apply -f "$RBAC_MANIFEST_PATH" || true
fi

# ================= 4. Install Whereabouts (FIXED) =================

echo "[INFO] Installing Whereabouts IPAM and CRDs..."
BASE_URL="https://raw.githubusercontent.com/k8snetworkplumbingwg/whereabouts/${WHEREABOUTS_VERSION}/doc/crds"

# 1. Install the DaemonSet
kubectl apply -f "${BASE_URL}/daemonset-install.yaml"

# 2. FIX: Install IPPools CRD
kubectl apply -f "${BASE_URL}/whereabouts.cni.cncf.io_ippools.yaml"

# 3. CRITICAL FIX: Patch OverlappingRangeIPReservation CRD
# The default CRD requires 'containerid', but the CNI plugin sometimes doesn't send it.
# We download, patch (remove the requirement), and then apply.
echo "[INFO] Patching OverlappingRange CRD to remove 'containerid' requirement..."
curl -sL "${BASE_URL}/whereabouts.cni.cncf.io_overlappingrangeipreservations.yaml" -o /tmp/crd-overlapping.yaml

# 使用 sed 刪除含有 "- containerid" 的那一行 (支援任意空白)
sed -i '/^\s*-\s*containerid/d' /tmp/crd-overlapping.yaml

kubectl apply -f /tmp/crd-overlapping.yaml
rm -f /tmp/crd-overlapping.yaml

echo "[INFO] Waiting for Whereabouts rollout..."
sleep 5
kubectl -n kube-system rollout status daemonset/whereabouts --timeout=300s

# Ensure RBAC applied takes effect: restart multus/whereabouts pods so they retry with new permissions
kubectl -n kube-system rollout restart daemonset/kube-multus-ds || true
kubectl -n kube-system rollout restart daemonset/whereabouts || true
kubectl -n kube-system rollout status daemonset/kube-multus-ds --timeout=120s || true
kubectl -n kube-system rollout status daemonset/whereabouts --timeout=120s || true
# ================= 5. Configure Macvlan NAD =================

echo "[INFO] Configuring Macvlan NetworkAttachmentDefinition..."
IPAM_JSON="{\"type\": \"whereabouts\", \"range\": \"$RANGE\""
if [ -n "$GATEWAY" ]; then
  IPAM_JSON="$IPAM_JSON, \"gateway\": \"$GATEWAY\""
fi
if [ "$NAD_DEFAULT_ROUTE" = "true" ] && [ -n "$GATEWAY" ]; then
  IPAM_JSON="$IPAM_JSON, \"routes\": [ { \"dst\": \"0.0.0.0/0\" } ]"
fi
IPAM_JSON="$IPAM_JSON}"

NAD_JSON="{\"cniVersion\": \"0.3.1\", \"type\": \"macvlan\", \"master\": \"$MASTER_IF\", \"mode\": \"bridge\", \"mtu\": 1400, \"ipam\": $IPAM_JSON}"

cat <<EOF > "$MANIFEST_PATH"
apiVersion: "k8s.cni.cncf.io/v1"
kind: NetworkAttachmentDefinition
metadata:
  name: $NAD_NAME
  namespace: $NAD_NAMESPACE
spec:
  config: '$NAD_JSON'
EOF
kubectl apply -f "$MANIFEST_PATH"

echo "[INFO] Configuring Storage Macvlan NetworkAttachmentDefinition..."
S_IPAM_JSON="{\"type\": \"whereabouts\", \"range\": \"$STORAGE_RANGE\""
if [ -n "$STORAGE_GATEWAY" ]; then
  S_IPAM_JSON="$S_IPAM_JSON, \"gateway\": \"$STORAGE_GATEWAY\""
fi
if [ "$STORAGE_DEFAULT_ROUTE" = "true" ] && [ -n "$STORAGE_GATEWAY" ]; then
  S_IPAM_JSON="$S_IPAM_JSON, \"routes\": [ { \"dst\": \"0.0.0.0/0\" } ]"
fi
S_IPAM_JSON="$S_IPAM_JSON}"

# choose master for storage: prefer STORAGE_IFACE if present
S_MASTER_IF="$STORAGE_IFACE"
if ! ip -o -f inet addr show "$S_MASTER_IF" >/dev/null 2>&1; then
  S_MASTER_IF="$MASTER_IF"
fi

S_NAD_JSON="{\"cniVersion\": \"0.3.1\", \"type\": \"macvlan\", \"master\": \"$S_MASTER_IF\", \"mode\": \"bridge\", \"mtu\": 1400, \"ipam\": $S_IPAM_JSON}"

cat <<EOF > "$STORAGE_MANIFEST_PATH"
apiVersion: "k8s.cni.cncf.io/v1"
kind: NetworkAttachmentDefinition
metadata:
  name: $STORAGE_NAD_NAME
  namespace: $STORAGE_NAD_NAMESPACE
spec:
  config: '$S_NAD_JSON'
EOF
kubectl apply -f "$STORAGE_MANIFEST_PATH"

# ================= 6. Verification =================
echo "[INFO] Verifying Installation..."

# Check Multus
MULTUS_PODS=$(kubectl get pods -n kube-system -l app=multus --field-selector=status.phase!=Running --no-headers 2>/dev/null | wc -l)
if [ "$MULTUS_PODS" -ne 0 ]; then
   echo "[ERROR] Some Multus pods are not running."
   exit 1
fi

# Check ippools CRD (Critical Check)
if ! kubectl get crd ippools.whereabouts.cni.cncf.io >/dev/null 2>&1; then
    echo "[ERROR] CRD 'ippools' not found. Whereabouts installation failed."
    exit 1
fi

echo "-------------------------------------------------------"
echo "[SUCCESS] Network Setup Complete."
echo "Range: $RANGE"
echo "CRDs for Whereabouts verified."
echo "-------------------------------------------------------"